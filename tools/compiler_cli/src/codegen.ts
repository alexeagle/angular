/**
 * Transform template html and css into executable code.
 * Intended to be used in a build step.
 */
import * as ts from 'typescript';
import * as path from 'path';
import * as compiler from 'angular2/compiler';

import {MetadataCollector, MetadataCollectorHost} from 'ts-metadata-collector';
import {NodeReflectorHost} from './reflector_host';
import {wrapCompilerHost} from './compiler_host';
import {RouterLinkTransform} from "angular2/src/router/directives/router_link_transform";

const SOURCE_EXTENSION = /\.[jt]s$/;
const PREAMBLE = `/**
 * This file is generated by the Angular 2 template compiler.
 * Do not edit.
 */
`;

export interface AngularCompilerOptions {
  // Absolute path to a directory where generated file structure is written
  genDir: string;
}

export type CodeGeneratorHost = ts.CompilerHost & MetadataCollectorHost;

export class CodeGenerator {
  constructor(private ngOptions: AngularCompilerOptions, private basePath: string,
              public program: ts.Program, public host: CodeGeneratorHost,
              private staticReflector: compiler.StaticReflector,
              private resolver: compiler.RuntimeMetadataResolver,
              private compiler: compiler.OfflineCompiler) {}

  private generateSource(metadatas: compiler.CompileDirectiveMetadata[]) {
    const normalize = (metadata: compiler.CompileDirectiveMetadata) => {
      const directiveType = metadata.type.runtime;
      const directives = this.resolver.getViewDirectivesMetadata(directiveType);
      const pipes = this.resolver.getViewPipesMetadata(directiveType);
      return new compiler.NormalizedComponentWithViewDirectives(metadata, directives, pipes);
    };

    return this.compiler.compileTemplates(metadatas.map(normalize));
  }

  private readComponents(absSourcePath: string) {
    const result: Promise<compiler.CompileDirectiveMetadata>[] = [];
    let metadata = this.staticReflector.getModuleMetadata(absSourcePath);

    if (!metadata) {
      console.log(`WARNING: no metadata found for ${absSourcePath}`);
      return result;
    }

    const symbols = Object.keys(metadata['metadata']);
    if (!symbols || !symbols.length) {
      return result;
    }
    for (const symbol of symbols) {
      const staticType = this.staticReflector.getStaticType(absSourcePath, symbol);

      let directive: compiler.CompileDirectiveMetadata;
      directive = this.resolver.maybeGetDirectiveMetadata(<any>staticType);

      if (!directive || !directive.isComponent) {
        continue;
      }
      result.push(this.compiler.normalizeDirectiveMetadata(directive).then((m) => {
        m.type.moduleUrl =
            'asset:tmp/lib/' + path.basename(absSourcePath).replace(SOURCE_EXTENSION, '');
        return m;
      }));
    }
    return result;
  }

  codegen() {
    const generateOneFile = (absSourcePath: string) =>
        Promise.all(this.readComponents(absSourcePath))
            .then((metadatas: compiler.CompileDirectiveMetadata[]) => {
              if (!metadatas || !metadatas.length) {
                return;
              }
              const generated = this.generateSource(metadatas);
              const sourceFile = this.program.getSourceFile(absSourcePath);

              // Write codegen in a directory structure matching the sources.
              // TODO(alexeagle): maybe use generated.moduleUrl instead of hardcoded ".ngfactory.ts"
              // TODO(alexeagle): relativize paths by the rootDirs option
              const emitPath =
                  path.join(this.ngOptions.genDir, path.relative(this.basePath, absSourcePath))
                      .replace(SOURCE_EXTENSION, '.ngfactory.ts');
              this.host.writeFile(emitPath, PREAMBLE + generated.source, false, () => {},
                                  [sourceFile]);
            })
            .catch((e) => { console.error('ERROR', e, e.stack); });

    return Promise.all(this.program.getRootFileNames().map(generateOneFile));
  }

  static create(ngOptions: AngularCompilerOptions, parsed: ts.ParsedCommandLine, basePath: string,
                originalHost: ts.CompilerHost):
      {errors?: ts.Diagnostic[], generator?: CodeGenerator} {
    const compilerHost = wrapCompilerHost(originalHost, parsed.options);
    const program = ts.createProgram(parsed.fileNames, parsed.options, compilerHost);
    const errors = program.getOptionsDiagnostics();
    if (errors && errors.length) {
      return {errors};
    }

    const metadataCollector = new MetadataCollector(compilerHost);
    const reflectorHost = new NodeReflectorHost(program, metadataCollector, compilerHost);
    const xhr: compiler.XHR = {get: (s: string) => Promise.resolve(compilerHost.readFile(s))};
    const urlResolver: compiler.UrlResolver = compiler.createOfflineCompileUrlResolver();
    const staticReflector = new compiler.StaticReflector(reflectorHost);
    const htmlParser = new compiler.HtmlParser();
    const normalizer = new compiler.DirectiveNormalizer(xhr, urlResolver, htmlParser);
    const parser = new compiler.Parser(new compiler.Lexer());
    const tmplParser = new compiler.TemplateParser(parser, new compiler.DomElementSchemaRegistry(),
                                                   htmlParser, [new RouterLinkTransform(parser)]);
    const offlineCompiler = new compiler.OfflineCompiler(
        normalizer, tmplParser, new compiler.StyleCompiler(urlResolver),
        new compiler.ViewCompiler(new compiler.CompilerConfig(true, true, true)),
        new compiler.TypeScriptEmitter());
    const resolver = new compiler.RuntimeMetadataResolver(
        new compiler.DirectiveResolver(staticReflector), new compiler.PipeResolver(staticReflector),
        new compiler.ViewResolver(staticReflector), null, null, staticReflector);
    return {
      generator: new CodeGenerator(ngOptions, basePath, program, compilerHost, staticReflector,
                                   resolver, offlineCompiler)
    };
  }
}
