/**
 * Transform template html and css into executable code.
 * Intended to be used in a build step.
 */
import * as ts from 'typescript';
import * as path from 'path';
import {MetadataCollector, MetadataCollectorHost} from 'ts-metadata-collector';
import {basename} from 'path';
import {StaticReflector, StaticReflectorHost} from "angular2/src/compiler/static_reflector";
import {NodeReflectorHost} from './reflector_host';
import {wrapCompilerHost} from './compiler_host';

import * as compiler from 'angular2/src/compiler/compiler';
// TODO(alexeagle): expose these through angular2/src/compiler/compiler as well?
import {RuntimeMetadataResolver} from 'angular2/src/compiler/runtime_metadata';
import {HtmlParser} from 'angular2/src/compiler/html_parser';
import {DirectiveNormalizer} from "angular2/src/compiler/directive_normalizer";
import {Lexer} from "angular2/src/compiler/expression_parser/lexer";
import {Parser} from "angular2/src/compiler/expression_parser/parser";
import {TemplateParser} from 'angular2/src/compiler/template_parser';
import {DomElementSchemaRegistry} from 'angular2/src/compiler/schema/dom_element_schema_registry';
import {StyleCompiler} from 'angular2/src/compiler/style_compiler';
import {ViewCompiler} from "angular2/src/compiler/view_compiler/view_compiler";
import {TypeScriptEmitter} from "angular2/src/compiler/output/ts_emitter";
import {RouterLinkTransform} from "angular2/src/router/directives/router_link_transform";

const SOURCE_EXTENSION = /\.[jt]s$/;
const PREAMBLE = `/**
 * This file is generated by the Angular 2 template compiler.
 * Do not edit.
 */
`;

export interface AngularCompilerOptions {
  // Absolute path to a directory where generated file structure is written
  genDir: string;

  // TODO(alexeagle): add more options, eg.
  // stripDesignTimeDecorators: boolean;
}

export type CodeGeneratorHost = ts.CompilerHost & MetadataCollectorHost;

export class CodeGenerator {
  constructor(private ngOptions: AngularCompilerOptions, public program: ts.Program,
              public host: CodeGeneratorHost, private staticReflector: StaticReflector,
              private resolver: RuntimeMetadataResolver,
              private compiler: compiler.OfflineCompiler) {}

  private generateSource(metadatas: compiler.CompileDirectiveMetadata[]) {
    const normalize = (metadata: compiler.CompileDirectiveMetadata) => {
      const directiveType = metadata.type.runtime;
      const directives = this.resolver.getViewDirectivesMetadata(directiveType);
      const pipes = this.resolver.getViewPipesMetadata(directiveType);
      return new compiler.NormalizedComponentWithViewDirectives(metadata, directives, pipes);
    };

    return this.compiler.compileTemplates(metadatas.map(normalize));
  };

  codegen() {
    const promises = this.program.getRootFileNames().map((absSourcePath) => {
      let metadata = this.staticReflector.getModuleMetadata(absSourcePath);

      if (!metadata) {
        console.log(`WARNING: no metadata found for ${absSourcePath}`);
        return;
      }

      const componentMetadatas: Promise<compiler.CompileDirectiveMetadata>[] = [];
      const symbols = Object.keys(metadata['metadata']);
      if (!symbols || !symbols.length) {
        return;
      }
      for (const symbol of symbols) {
        const staticType = this.staticReflector.getStaticType(absSourcePath, symbol);

        let directive: compiler.CompileDirectiveMetadata;
        try {
          directive = this.resolver.getDirectiveMetadata(<any>staticType);
        } catch (e) {
          // TODO: directive resolver throws on non-directive symbols
          // for now, just catch those and continue
          if (e.message && e.message.indexOf('No Directive annotation') == 0) {
            continue;
          }
          console.error(e);
          throw e;
        }
        if (!directive.isComponent) {
          continue;
        }
        componentMetadatas.push(this.compiler.normalizeDirectiveMetadata(directive).then((m) => {
          m.type.moduleUrl =
              'asset:tmp/lib/' + basename(absSourcePath).replace(SOURCE_EXTENSION, '');
          return m;
        }));
      }

      return Promise.all(componentMetadatas)
          .then((metadatas: compiler.CompileDirectiveMetadata[]) => {
            if (!metadatas || !metadatas.length) {
              console.log(`Not writing template for ${absSourcePath}: no metadatas`);
              return;
            }
            const generated = this.generateSource(metadatas);
            const sourceFile = this.program.getSourceFile(absSourcePath);
            // We use program.emit to map source file locations to output file locations.
            this.program.emit(sourceFile, (jsEmitPath: string) => {
              // Instead of outDir/file.js we want to write to genDir/file.ngfactory.ts
              // TODO(alexeagle): maybe use generated.moduleUrl instead of hardcoded ".ngfactory.ts"
              const emitPath = jsEmitPath.replace(this.program.getCompilerOptions().outDir,
                                                  this.ngOptions.genDir)
                                   .replace(SOURCE_EXTENSION, '.ngfactory.ts');
              this.host.writeFile(emitPath, PREAMBLE + generated.source, false, () => {}, [sourceFile]);
            });

          })
          .catch((e) => { console.error('ERROR', e, e.stack); });
    });

    return Promise.all(promises).then(() => {});
  }

  // TODO: use DI to create this object graph??
  static create(ngOptions: AngularCompilerOptions, parsed: ts.ParsedCommandLine,
                originalHost: ts.CompilerHost):
      {errors?: ts.Diagnostic[], generator?: CodeGenerator} {
    const compilerHost = wrapCompilerHost(originalHost, parsed.options);
    const program = ts.createProgram(parsed.fileNames, parsed.options, compilerHost);
    const errors = program.getOptionsDiagnostics();
    if (errors && errors.length) {
      return {errors};
    }

    const metadataCollector = new MetadataCollector(compilerHost);
    const reflectorHost = new NodeReflectorHost(program, metadataCollector, compilerHost);
    const xhr: compiler.XHR = {get: (s: string) => Promise.resolve(compilerHost.readFile(s))};
    const urlResolver: compiler.UrlResolver = compiler.createOfflineCompileUrlResolver();
    const staticReflector = new StaticReflector(reflectorHost);
    const htmlParser = new HtmlParser();
    const normalizer = new DirectiveNormalizer(xhr, urlResolver, htmlParser);
    const parser = new Parser(new Lexer());
    const tmplParser = new TemplateParser(parser, new DomElementSchemaRegistry(), htmlParser,
                                          [new RouterLinkTransform(parser)]);
    const offlineCompiler = new compiler.OfflineCompiler(
        normalizer, tmplParser, new StyleCompiler(urlResolver),
        new ViewCompiler(new compiler.CompilerConfig(true, true, true)), new TypeScriptEmitter());
    const resolver = new RuntimeMetadataResolver(
        new compiler.DirectiveResolver(staticReflector), new compiler.PipeResolver(staticReflector),
        new compiler.ViewResolver(staticReflector), null, null, staticReflector);
    return {
      generator: new CodeGenerator(ngOptions, program, compilerHost, staticReflector, resolver,
                                   offlineCompiler)
    };
  }
}
